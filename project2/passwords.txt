Password 1:  bWwoPyACiGEBFbgOOEANJI

Disassemebled the main function, saw that directly after the call to “chomp”, there was something at a memory address being moved into %esi.  I looked at that value, tried it as the password and was correct.

Password 2:  must be a palindrome > 7 characters

After disassembling the main function, I saw there were calls to functions c, s, and p.  In the c function, s is called 3 times, and none of the jump comparisons executed.  After disassembling the s function, it was obvious that s calculated the length of the inputted password string passed on ebp, and returned the value in eax.  However, after serious examination into the c function, I couldn’t determine any real use for it and moved onto the p function, where it was obvious that p was doing something.  
I determined that p checks to see if the inputted password is a palindrome or not.  I figured this out by examining what value was dereferenced by the %edi register in the cmp instruction at 0x080484be during each iteration in p.  It only went through one iteration the first few times I debugged because I didn’t know my password had to be a palindrome (the loop only executed once if the first and last chars weren’t equal).  However, on the first iteration each time I saw that the last character on my input string was stored in what %edi dereferenced.  I then saw in the assembly that if the two are equal, it subtracts one from %edi, and adds one to another register, and then will do the same comparison again after a call to s and some other manipulations.  I then figured out that %AL holds the lowest 8 bits (1 byte) in eax, so I thought that it could be testing to see if the beginning char was equal to the ending char.  When I tried a password whose first and last chars were equal, I found that the loop executed twice, but no more.  On the second iteration however, the value %edi dereferenced was the second to last character + the last character (in that order).  That led me to believe that the function was ultimately trying to compare the two halves of the input (adding a character each iteration), which seemed like a palindrome (this also explained why it was subtracting one from %edi – to change the spot in the string its comparing).  I then tried a password that was a palindrome, and found that the loop executed an amount about equal to half of the string, and that the value dereferenced by %edi in the last iteration was the second half of the input.  I knew before I even began debugging that if p doesn’t return 1, the input is wrong (it jumps to the end of main if %eax != 1).  The only time I got p to return 1 to %eax was with the palindrome, so I knew that my thought process was correct and that the password had to be a palindrome of some sort (I had been trying racecar).  
 However I still wasn’t getting the right password so I knew I was missing a component.  The next function called was s, which returns the length of the input in %eax. I saw that the program jumped to the end of main if %eax was less than or equal to 7, so I then thought that the missing component was that the input had to be a palindrome of length 8 or greater.  After knowing that, every palindrome >= 8 I tried worked successfully.   
Passwords that worked:
aaaaaaaa
kekkekkek

3.  
I first tried to use the gdb to trace through this program, but quickly realized that there was no defined “main” method, so I would have to try different tools.  I then used “objdump –D” to get all of the assembly code, and then focused on the .text section, because I know that the code for the executable had to be in that section.  After then setting some arbitrary break points and then using the gdb and specifically the “ni” command within the gdb, I came to the conclusion that the main method starts at 0x8048454.  Next, I realized that the string the user enters is inputted at 0x804846e, and it has to be 10 characters, or it will stall and keep asking until it reaches 10.  It then loops through the 10 characters and makes them each lowercase.  
There Is then a new loop that starts at 0x8048492.  This loop goes to 0x80484bd, and it is in this loop that the program determines whether or not the password is correct.  First, this loop gets each character in the string on each iteration.  It then subtracts 0x31 (49 in decimal) from each character, and then compares that value to 4.  If that value <= 4, it increments a counter, specifically -10(%ebp).  The only character values that could do this are (1, 2, 3, 4, 5).  On any other character value, that counter will not increment (it jumps to the position right below that increment instruction on any other character).  This loop executes a total of 10 times because it loops through each character in the string.  
The next instruction at the end of the loop is a comparison to make sure that our counter (the one that incremented only when a char – 31 <= 4) is exactly the value of 5.  If that value is 5, the password that was entered was correct.  If its less than 5 or greater than 5, then the password is not correct.
In summary, the password needs to have 5 characters exactly that are either (1, 2, 3, 4, 5).  The values of the other 5 characters in the password do not matter.  

Examples of passwords that worked:
12345aaaaa
aa11111bbb
!!!!!22333

